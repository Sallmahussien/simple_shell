#include "main.h"

/**
 * check_change_dir - checks if change dir == 0 or not
 * @curr_cwd: current cwd
 * @new_dir: the new dir will be moved to
 * @name: variable name in linked list
 * @head: head node of linked list
 * Return: 0 or 1
 */

int check_change_dir(char *curr_cwd, char *new_dir, char *name, node **head)
{
	node *env_list;

	env_list = *head;
	if (change_dir(new_dir, curr_cwd, &env_list) == 0)
	{
		free(name);
		free(new_dir);
		return (0);
	}
	else
	{
		free(name);
		free(new_dir);
		return (2);
	}
}


/**
 * null_dir - move to home directory
 * @head: head node of environment linked list
 * Return: 0 or 1
 */

int null_dir(char *curr_cwd, node **head)
{
	node *env_list = *head;
	char *new_dir = NULL, *name;
	int i, ii = 0;

	while (env_list != NULL)
	{
		if (env_list->data == NULL)
		{
			perror("env_list");
			return (2);
		}
		else
		{
			name = get_linked_list_var(env_list);
			if (_strcmp(name, "HOME") == 0)
			{
				new_dir = malloc(sizeof(char) * (_strlen(env_list->data) - 4));
				if (new_dir == NULL)
				{
					perror("malloc")
					return (2);
				}
				for (i = 5; env_list->data[i]; i++)
					new_dir[ii++] = env_list->data[i];
				new_dir[ii] = '\0';
				if (check_change_dir(curr_cwd, new_dir, name, &env_list) == 0)
					return (0);
				else
					return (2);
			}
		}
		free(name);
		free(new_dir);
		env_list = env_list->next;
	}
	return (2);
}


/**
 * past_dir - move to home directory
 * @head: head node of environment linked list
 * Return: 0 or 2
 */

int past_dir(char *curr_cwd, node **head)
{
	node *env_list = *head;
	char *new_dir = NULL, *name;
	int i, ii = 0;

	while (env_list != NULL)
	{
		if (env_list->data == NULL)
		{
			perror("env_list\n");
			return (2);
		}
		else
		{
			name = get_linked_list_var(env_list);
			if (_strcmp(name, "OLDPWD") == 0)
			{
				new_dir = malloc(sizeof(char) * (_strlen(env_list->data) - 6));
				if (new_dir == NULL)
				{
					perror("malloc");
					return (2);
				}
				for (i = 7; env_list->data[i]; i++)
					new_dir[ii++] = env_list->data[i];
				new_dir[ii] = '\0';
				if (check_change_dir(curr_cwd, new_dir, name, &env_list) == 0)
					return (0);
				else
					return (2);			}
		}
		free(name);
		free(new_dir);
		env_list = env_list->next;
	}
	return (2);
}

/**
 * change_dir - changes the dir to the headed one
 * @dir: directry name
 * @curr_cwd: current cwd
 * @head: head node of linked list
 * Return: 0 or -1
 */

int change_dir(char *dir,  char *curr_cwd, node **head)
{
	node *env_list;
	char cwd[300], char *err;

	env_list = *head;
	if (chdir(dir) == 0)
	{
		set_env("PWD", dir, &env_list);
		set_env("OLDPWD", curr_cwd, &env_list);
		if (getcwd(cwd, sizeof(cwd)) == NULL)
		{
			perror("getcwd");
			return (2);
		}
		return (0);
	}
	else
	{
		write(STDERR_FILENO, argv[0], _strlen(argv[0]));
		write(STDERR_FILENO, ": ", 2);
		err = tostring(history);
		Write(STDERR_FILNO, tostring(err), _strlen(err));
		Write(STDERR_FILENO, ": ", 2);
		Write(STDERR_FILENO, arr[0], _strlen(arr[0]));
		Write(STDER_FILENO, ": canâ€™t cd to ");
		Write(STDERR_FILENO, arr[1], _strlen(arr[1]));
		Write(STDERR_FILENO, arr[1], _strlen(arr[1]));
		write(STDERR_FILENO, "\n", 1);
		free(err);

		return (2);
	}
}

/**
 * change_dir_direct - changes the dir to directry in the current cwd
 * @dir: directry name
 * @curr_cwd: current cwd
 * @head: head node of linked list
 * Return: 0 or 2
 */

int change_dir_direct(char *dir, char *curr_cwd, node **head)
{
	node *env_list = *head;
	char *new_dir;

	new_dir = malloc(sizeof(char) * (_strlen(curr_cwd) + _strlen(dir) + 2));
	if (new_dir == NULL)
	{
		perror("malloc");
		return (2);
	}
	_strcpy(new_dir, curr_cwd);
	_strcat(new_dir, "/");
	_strcat(new_dir, dir);
	new_dir[_strlen(new_dir)] = '\0';

	if (change_dir(new_dir, curr_cwd, &env_list) == 0)
	{
		free(new_dir);
		return (0);
	}
	else
	{
		free(new_dir);
		return (2);
	}
}

/**
 * back_dir - change dir step back
 * @curr_cwd - current cwd
 * @head: head node of linked list
 * Return: 0 or 2
 */


int back_dir(char *curr_cwd, node **head)
{
	node *env_list;
	char *new_dir;
	int i, len = 0, count = 0, num = 0;

	env_list = *head;
	for (i = 0; curr_cwd[i] != '\0'; i++)
	{
		if (curr_cwd[i] == '/')
			count++;
	}
	for (i = 0; curr_cwd[i] != '\0'; i++)
	{
		if (curr_cwd[i] == '/')
			num++;
		if (num == count)
			break;
	}
	len = i;
	new_dir = malloc(sizeof(char) * (len + 1));
	for (i = 0; i < len; i++)
		new_dir[i] = curr_cwd[i];
	new_dir[i] = '\0';
	if (change_dir(new_dir, curr_cwd, &env_list) == 0)
	{
		free(new_dir);
		return (0);
	}
	else
	{
		free(new_dir);
		return (2);
	}
}

/**
 * _cd - Changes the current directory of the process.
 * @dir: the dir that will changed to
 * @value: not used
 * @head: head node of the linked list of the environment
 * Return: 0 on success or 2 on falier
 */

int _cd(char *dir, char *value, node **head)
{
	char curr_cwd[300], *new_dir = NULL;
	node *env_list;
	int ret;

	UNUSED(value);
	env_list = *head;
	if (getcwd(curr_cwd, sizeof(curr_cwd)) == NULL)
	{
		perror("getcwd");
		return (2);
	}

	if (dir == NULL)
		ret = null_dir(curr_cwd, &env_list);
	else if (dir[0] == '/')
		ret = change_dir(dir, curr_cwd, &env_list);
	else if (_strcmp(dir, "..") == 0)
	{
		if (_strcmp(curr_cwd, "/") == 0)
			return (0);
		ret = back_dir(curr_cwd, &env_list);
	}
	else if (_strcmp(dir, "-") == 0)
		ret = past_dir(curr_cwd, &env_list);
	else
		ret = change_dir_direct(dir, curr_cwd, &env_list);

	return (ret);
}


/**int main(int argc,char **argv)
{
  node *env_list;
  char **env = environ, *arg = NULL;

  env_list = get_env_list(env);

  _cd(argv[1], "whateever", &env_list);
//argv[1] = array[1], whatwever = unused(value)

  free_list(env_list);
  return (0);
}*/
